"""By using execfile(this_file, dict(__file__=this_file)) you will
activate this virtualenv environment.

######  documentation says  It is different from the import statement in that it does not use the module administration — 
####it reads the file unconditionally and does not create a new module.
##### apparently reads the file using the namespace saved in the globals and local dictionaries  
######   ???   the second argument is supposed to be 'globals' meaning the dictionary of namespace.  why are you creating a dictionary out of this file.  
#####  __file__.   you are setting __file__ equal to the full path name of the activate_this.py file we are in now.  


This can be used when you must use an existing Python interpreter, not
the virtualenv bin/python
####??? I thought the whole script below is meant to create a virtual environemnt.   Not to handle
#### a situation in which you cannot use a virtual env and must use the interpreter
"""

try:
    __file__

except NameError:
    raise AssertionError(
        "You must run this like execfile('path/to/activate_this.py', dict(__file__='path/to/activate_this.py'))")
import sys
import os

old_os_path = os.environ['PATH']
#######   get's the path name of the home directory
os.environ['PATH'] = os.path.dirname(os.path.abspath(__file__)) + os.pathsep + old_os_path
######## ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
######## ???? are you creating a variable called os.environ['PATH'] or are you telling python to reset the pathname of the directory?
########  right side is the asbolute path of the module, os.pathsep gives the way paths are separated in the OS,
######  for windows it's ;  and then the old_os_path from above
base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
#######   ?????   gets absolute path of the module, then get the directory of that absolute path.   why is it sent to dirname twice?
if sys.platform == 'win32':
    site_packages = os.path.join(base, 'Lib', 'site-packages')
#######   os.path.join intelligently combines paths,  throwing away higher directories that would be redundant, then you add the string "Lib" and "site-packages"
#######  i assume join puts the appropriate file path delimeter for the os,  in this case ;
else:
    site_packages = os.path.join(base, 'lib', 'python%s' % sys.version[:3], 'site-packages')
######  ??  seems to add on to end of string 'python' the first two element of sys.version.  why do this only if platform is not win32? 
######  would sys.version[:3] return the python version, like '2.7' 
prev_sys_path = list(sys.path)
###### creates a list with each list element being a different absolute path
######  ???  what do these paths from sys.path do?
import site
site.addsitedir(site_packages)
##### adds the path of the new module to the system path and runs it's .pth  file
##### ????  what does .pth do?
sys.real_prefix = sys.prefix
#??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#####  ???? are you creating a new variable called sys.real_prefix or somehow resetting sys.real_prefix 
#####  Seem to be setting to the python directory (which is C:// and python version name eg Python27")
#### which is what sys.prefix returns
sys.prefix = base
#??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#### ???  are you creating a new variable with name 'sys.prefix' or are you somehow setting the system prefix to be base 
# Move the added items to the front of the path:
####  base is directory name of the module.   
new_sys_path = []
for item in list(sys.path):
    if item not in prev_sys_path:
        new_sys_path.append(item)
        sys.path.remove(item)
#??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#######   ?  removing an element from sys.path    Does this change the system path elements or just a copied list    
sys.path[:0] = new_sys_path
#??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
#????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
###########  the index [:0] is 'before' the first element so it's going to always be null.   why is it being set to new_sys_path 
